// This file tests ownership transfer and linearity.

main resource contract BogusMoney {
	 // Error: constructor must return an owned reference
	 BogusMoney() {
	 }
}

resource contract Money {
    Money@Owned() {

    }
}

resource contract Wallet {
    Money@Owned money;

    Wallet@Owned(Money@Owned m) {
        money = m;
    }

    transaction loseMoney (Money@Owned m) {
        // OK: m's ownership is returned to the caller
    }

    transaction stealMoney (Money@Unowned m) {
        money = m;
        // Error: type of money is inconsistent with declaration.
    }

    transaction returnMoney (Money@Owned >> Unowned m) returns Money@Owned {
    	return m;
    }

    transaction failToReturnMoney (Money@Unowned m) returns Money@Owned {
        // Error: can't return unowned m when owned Money is required
        return m;
    }
}

contract BadWallet {
    // Error: can't own a resource in a non-resource contract.
    Money@Owned money;
}

contract Disowning {
	 transaction bogusDiscardMoney (Money@Unowned m) {
	 	     // Error: m is unowned
	 	     disown m;
	 }

	 transaction discardMoney (Money@Owned >> Unowned m) {
     	 	 disown m;

     	 	 // Error: m is shared.
     	 	 discardMoney(m);

             // Error: m is shared. Want to make sure we can't consume m twice.
     	 	 Money@Owned bad = m;
     }

     transaction getMoney() returns Money@Owned {
        return new Money();
     }

     transaction discardMoneyCall () {
        disown getMoney();
        Money@Unowned m = disown getMoney(); // disown is an expression, not just a statement
     }
}

contract LosingResource {
    transaction bogus (Money@Owned >> Unowned m) returns Money@Unowned {
        // Error: losing m.
        return m;
    }
}