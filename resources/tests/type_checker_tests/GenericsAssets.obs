asset contract C {}

contract Identity[X@s] {
    transaction id(X@s >> Unowned x) returns X@s {
        return x;
    }
}

contract AssetIdentity[asset X@s] {
    transaction id(X@s >> Unowned x) returns X@s {
        return x;
    }
}

interface Go[Y] {
    state A;

    transaction go(Go[Y]@Owned >> A this);
}

contract D implements Go[C@Owned] {
    state A;

    D@A() {
        ->A;
    }

    transaction go(D@Owned >> A this) {
        ->A;
    }
}

/* contract BadAssetManager[(asset X implements Go[C@Owned]) @ (s <: Owned)] { */
/* contract BadAssetManager[asset X@s */
/*                          where X implements Go[C@Owned] */
/*                          where s is Owned] { */
/* contract BadAssetManager[asset X@s */
/*                          where X implements Go[C@Owned] */
/*                             where C implements Foo */
/*                          where s is Owned] { */
/* contract BadAssetManager[C@s implements Go[D@t], D@t implements Go[C@s]] */

contract BadAssetManager[asset X@s implements Go[C@Owned]@Owned] {
    // error, because x could be an owned asset
    transaction drop(X@s >> Unowned x) {}

    transaction boundTest(X@s >> Unowned x) returns X@A {
        x.go();
        return x;
    }
}

contract BadBound[X@s implements Go@Unowned] {
    transaction boundTest(X@s >> Unowned x) returns X@A {
        x.go(); // error, we don't know that x is owned
        return x;
    }
}

main contract Main {
    transaction f() {
        AssetIdentity[C@Owned] temp1 = new AssetIdentity[C@Owned](new C()); // This is fine
        Identity[C@Owned] temp2 = new Identity[C@Owned](new C()); // This should fail, because identity can only hold non-assets
    }
}

