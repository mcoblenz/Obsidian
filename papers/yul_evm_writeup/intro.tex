Obsidian~\cite{Coblenz2020:Obsidian} is a novel programming language for writing smart contracts that provides strong safety guarantees. Obsidian's type system ensures that transactions are only invoked on contracts that are in appropriate states for those invocations. It also ensures that critical assets, such as virtual currencies, cannot be lost without an explicit operation to discard them. Obsidian was created using user-centered design techniques~\cite{Coblenz2021:PLIERS}, and was shown to be more effective than Solidity for programmers for some kinds of programming tasks~\cite{Coblenz2020:Can}. The initial implementation of Obsidian targeted the Hyperledger Fabric blockchain platform~\cite{Fabric}, which is a \emph{permissioned} blockchain: it assumes that a small number of nodes will host the system, and that only authorized users will use the system. 

In order to broaden Obsidian's applicability, we prototyped support for the Ethereum~\cite{Ethereum} blockchain platform. This presented two interesting challenges that may be applicable to other platforms as well. The first challenge pertained to persistence: at the end of a transaction, the new values of all written fields must be persisted. The Fabric target of Obsidian accomplishes this by serializing data using Protocol Buffers. This approach is not appropriate for Ethereum, since Protocol Buffers does not offer an EVM target. Even if it did, on Ethereum it is especially important to minimize the cost of serialization. Protocol Buffers instead places higher priority on portability. To persist fields on Ethereum, we arranged for the Obsidian compiler to emit code that, at the end of transactions, serializes fields directly to storage using appropriate encodings for each type.

The second question is how memory is managed. On Fabric, Obsidian is translated to Java code, leveraging the built-in garbage collector. This is convenient, since Obsidian is a garbage-collected language. On Ethereum, there is no garbage collector. Garbage collector implementation is known to be extremely tricky; in addition, we wanted to minimize runtime costs of memory management on Ethereum. The approach we took leverages the two separate memory areas on Ethereum. New objects are allocated in \textit{memory}, which is volatile and can be allocated and written to cheaply. However, the runtime maintains the invariant that fields in storage only refer to objects in storage, not objects in memory. When a field of a persistent object is written (via an assignment in the program), if the assignment points to an address in memory, the object subgraph to which it refers is migrated to storage as well.

At the end of a transaction, the Ethereum runtime automatically discards the contents of memory. However, the runtime must explicitly free discarded objects in storage when they are no longer needed. Each storage object includes a reference count, which tracks the number of references to that object. Each object supports \obssrc{retain} and \obssrc{release} methods: \obssrc{retain} increments the reference count, and \obssrc{release} decrements the count. If the new count is 0, \obssrc{release} also \emph{wipes} the object by setting its fields to zero, enabling a potential gas refund from the Ethereum runtime. At the moment, the programmer must insert calls to \obssrc{retain} and \obssrc{release} manually; the long-term plan is for the compiler to do so automatically, enabling additional optimization opportunities. 

The compiler targets the Yul~\cite{Yul} intermediate language in order to maximize opportunities for optimization. We also hope that in the long term, it will be beneficial for the Yul ecosystem to have additional source languages that will compile to it, in addition to Solidity.

In the rest of the paper, we describe the approach that we use to translate Obsidian contracts to Yul programs as well as the results of our performance evaluation.

TODO: describe results.