In general, an Obsidian program consists of a collection of contracts, one of which is the \obssrc{main} contract. The general shape of the
Yul object emitted as a result of translating an Obsidian program is given in
Figure \ref{code.1}. The \emph{deployment block} consists of code that is executed when the main contract is deployed; the \emph{invocation block} contains implementations of all transactions that can be invoked on the deployed contract. The chief responsibility of the deployment block is to initialize the memory allocation mechanism, allocate one instance of the main contract, and persist that instance in storage.


\begin{figure}[hbtp]
    \caption{Structure of Generated Yul Object}
    \label{code.1}
    \begin{lstlisting}[language=yul,frame=single,numbers=none]
object "MainContractName" {
    code { // the deployment block
        // 1. memory allocation 
        // 2. default constructor for main 
        // 3. generated tracers (
        // 4. build the default main contract instance, trace it
    }
    object "MainContractName_deployed" { // the invocation block
        // 1. sanity checks
        // 2. dispatch table, inspecting calldataload, using main contract
          //   in storage
        // 3. memory allocation (same as deployment block)
        // 4. utility functions for abi encoding and decoding
        // 5. translated transactions, including gc and constructors
        // 6. generated constructors (for main, same as deployment block)
        // 7. generated tracers (same as in deployment block)
        // 8. generated wipers
    }
}
    \end{lstlisting}
\end{figure}

In the rest of this section, we will describe how Obsidian code is translated to Yul, leveraging the running example shown in Figure \ref{code.2}. As we describe different
aspects of the translation, we provide examples of the emitted code
produced when translating this contract. 



\begin{figure}[hbtp]
    \caption{Example Obsidian Getter/Setter Contract Pair}
    \label{code.2}
    \begin{lstlisting}[language=obsidian,frame=single,numbers=none]
contract IntContainer {
    int x;

    transaction set(int value) {
        x = value;
    }
    transaction get() returns int {
        return x;
    }
}

main contract SetGetWithArgs {
    transaction main() returns int {
        IntContainer ic = new IntContainer();
        ic.set(5);
        return (ic.get());
    }
}
    \end{lstlisting}
\end{figure}



\subsection{Default Constructors}

Constructors are responsible for initializing fields of contracts. The compiler emits a default constructor transaction for any contract that
lacks a constructor. This default constructor takes
enough arguments to populate the fields of the contract. Space
for each argument is allocated in memory and the argument values are
written there. To allocate fields of nonprimitive type, the compiler computes the size required, allocates space for the referenced object, and calls the appropriate constructor. 

If a particular field is not of primitive type, then its
respective default constructor is called recursively. with an appropriate
slice of the arguments and the space allocated in memory for the instance
of the parent object is populated with a pointer to the instance built by
the constructor for the child object. In this way, we guarantee that there
is always a way to build an instance of each object in memory.

\begin{figure}[hbtp]
    \caption{Default Constructors}
    \label{code.3}
    \begin{lstlisting}[language=yul,frame=single]
function SetGetWithArgs___SetGetWithArgs0x050caf6b(this, con_arg____refcount) {
    // default constructor generated by the compiler
    // this.__refcount := con_arg____refcount
    switch gt(add(this, 0), sub(shl(255, 1), 1))
    case 1 {sstore(add(this, 0), con_arg____refcount)}
    case 0 {mstore(add(this, 0), con_arg____refcount)}
}

function IntContainer___IntContainer0x13e375fe(this, con_arg____refcount, con_arg__x) {
    // default constructor generated by the compiler
    // this.__refcount := con_arg____refcount
    switch gt(add(this, 0), sub(shl(255, 1), 1))
    case 1 {sstore(add(this, 0), con_arg____refcount)}
    case 0 {mstore(add(this, 0), con_arg____refcount)}

    // this.x := con_arg__x
    switch gt(add(this, 32), sub(shl(255, 1), 1))
    case 1 {sstore(add(this, 32), con_arg__x)}
    case 0 {mstore(add(this, 32), con_arg__x)}
}
\end{lstlisting}
\end{figure}

\subsection{Tracers}
In order to maintain the invariant that objects in storage only refer to objects in storage (and not objects in memory), the compiler emits code for each assignment to a field. If the field is in storage and would point to an address in memory, a \emph{tracer} is invoked to trace the referenced object graph and copy each object to storage. The compiler emits one tracer per contract; the tracer takes as input the address
in memory of an instance and copies its fields to
storage. Fields of primitive type are copied directly. Fields of
non-primitive type, which store pointers to instances of other objects, are
copied by calling the relevant tracer for the contract type recursively on
the referenced object. \Cref{fig:tracers} shows example tracers. We show them unoptimized to improve readability; the Yul optimizer makes them significantly more efficient. In lines 3--4, the tracer copies the context of field \obssrc{x}, which is 0 bytes after the start of \obssrc{this} (which is assumed to be in memory), to the corresponding address in storage. If \obssrc{IntContainer} had more fields, we would see additional copy operations; if any of those were references to other objects, we would see calls to the corresponding tracers. This version includes logging code, used for debugging purposes; the logging is more convoluted than one might expect because \yulsrc{log0} takes a pointer, so the tracer must first allocate memory and populate it before invoking \yulsrc{log0}.

To distinguish pointers to storage from pointers to memory, Obsidian only uses memory addresses less than
a \emph{threshold value} of $2^{256}/2$. In contrast, all addresses in storage are greater or equal to
the threshold. This offset invariant effectively halves the size of storage, but
by doing so allows us to know at runtime where an address points and use the
appropriate commands on it, e.g., choosing between \yulsrc{mload}
and \yulsrc{sload}. Since storage is so large and the smart contracts we
are interested in are modest in size, the storage reduction is not
problematic.

To maintain this invariant, when a tracer writes a reference to storage,
the address value of the pointer itself is increased by the threshold
value. Since the other tracers do the same, inductively we know that this
shifting operation will preserve structures as they are copied.

\begin{figure}[hbtp]
    \caption{Tracers, with logging}
    \label{code.4}
    \begin{lstlisting}[language=yul,frame=single]
function trace_SetGetWithArgs(this) {
    // loading
    sstore(add(add(this, 0), shl(255, 1)), 
           mload(add(this, 0)))
    // logging
    let _tmp_37 := allocate_memory(32)
    mstore(_tmp_37, 
           sload(add(add(this, 0), shl(255, 1))))
    log0(_tmp_37, 32)
    leave
}

function trace_IntContainer(this) {
    // loading
    sstore(add(add(this, 0), shl(255, 1)), mload(add(this, 0)))
    // logging
    let _tmp_38 := allocate_memory(32)
    mstore(_tmp_38, 
           sload(add(add(this, 0), shl(255, 1))))
    log0(_tmp_38, 32)
    // loading
    sstore(add(add(this, 32), shl(255, 1)), 
           mload(add(this, 32)))
    // logging
    let _tmp_39 := allocate_memory(32)
    mstore(_tmp_39, 
           sload(add(add(this, 32), shl(255, 1))))
    log0(_tmp_39, 32)
    leave
}
    \end{lstlisting}
    \label{fig:tracers}
\end{figure}

\subsection{Wipers}
Assignment to fields may result in \emph{garbage} in storage: allocated space in storage that is no longer referenced by any field in storage. When the reference count of a storage object is decremented to 0, which occurs as a result of a call to \obssrc{release}, the \obssrc{release} implementation invokes the appropriate \obssrc{wipe} function to write zeros to the object's storage. The wipers follow the same recursive call structure induced by the
dependency tree of the contracts in question, but rather than copying an
instance from memory to storage they write zeroes to all the storage
spaces. This triggers a 15,000 gas refund~\cite{YellowPaper} as long as the object had nonzero-value fields. \Cref{code.5} shows an example wiper implementation, including logging for debugging purposes.

\begin{figure}[hbtp]
    \caption{Wipers, with logging}
    \label{code.5}
    \begin{lstlisting}[language=yul,frame=single]
function wipe_SetGetWithArgs(this) {
    // wiping
    sstore(add(this, 0), 0)
    // logging
    let _tmp_40 := allocate_memory(32)
    mstore(_tmp_40, 20)
    log0(_tmp_40, 32)
    leave
}

function wipe_IntContainer(this) {
    // wiping
    sstore(add(this, 0), 0)
    // logging
    let _tmp_41 := allocate_memory(32)
    mstore(_tmp_41, 20)
    log0(_tmp_41, 32)
    // wiping
    sstore(add(this, 32), 0)
    // logging
    let _tmp_42 := allocate_memory(32)
    mstore(_tmp_42, 20)
    log0(_tmp_42, 32)
    leave
}
    \end{lstlisting}
\end{figure}


\subsection{Deployment}

The main task at deployment time is to build an instance of the main
contract in memory and then copy that to storage. This copy serves as the
root object for garbage collection. Note that three of the main components
in this block are copied verbatim from general purpose versions that exist
at invocation time, lower in the emitted object; this is a site for future
optimization.

To that end, the compiler emits a block of Yul for deployment. The block begins with a copy of the memory
allocator and associated utility functions, followed by the generated
default constructors and tracers. Currently we emit all the constructors
and tracers, although they may not be needed; this is site for future
optimization. We allocate enough memory for a copy of the main contract,
use the emitted constructor to build it there, then run the tracer on it to
copy it to storage. Because we know the first address that allocator will
give in memory and the mapping the tracer applies to addresses to compute
their place in storage, we know where this will live in storage and that
serves as the \emph{root}.

\begin{figure}[hbtp]
    \caption{Building the Root}
    \label{code.6}
    \begin{lstlisting}[language=yul,frame=single]
let this := allocate_memory(32)
SetGetWithArgs___SetGetWithArgs0x050caf6b(this, 5738)
trace_SetGetWithArgs(this)
    \end{lstlisting}
\end{figure}

\subsection{Invocation}

Instances of Obsidian objects can refer to one another, so their
translations in to Yul must be able to as well. This means at least that
they must have access to the same memory during execution. To that end, we
\emph{flatten} the contracts into one object structured as in Figure
\ref{code.1}.

\begin{figure}[hbtp]
    \caption{Dispatch Table}
    \label{code.7}
    \begin{lstlisting}[language=yul,frame=single]
// fixed address of the root
let this := add(shl(255, 1), 128)

let selector := shr(224, calldataload(0))
switch selector
case 0xd1665b62 {// entry for SetGetWithArgs___main
    if callvalue() {revert(0, 0)}
    // SetGetWithArgs___main takes no parameters
    let _dd_ret_1 := SetGetWithArgs___main(this)
    let memPos := allocate_unbounded()
    let memEnd := abi_encode_tuple_to_fromStack1(memPos, _dd_ret_1)
    return(memPos, sub(memEnd, memPos))
    }
    \end{lstlisting}
\end{figure}

The block of Yul code that supports invocation begins with checks against the structure of the call and then
inspects the call data in the dispatch table to determine which transaction
to run, per the ABI encoding. The available transactions are the ones in
the main contract that are not private and not constructors. The
transaction is run against the instance of the main contract that's been
built and copied to storage in the deployment block, which we can assume
has been run first. We know the address in storage of this root instance
statically, since we know the first address that the allocator will emit as
well as the threshold value by which it will have been offset.

The emitted code includes a simple memory allocator and functions for
manipulating data against the ABI specified encoding and decodings.  After the allocator, we emit translations of the transactions from the
contracts. The name of each transaction is prefixed with the name of its
origin contract in the translation; the structure of Obsidian files
guarantees that this is unique. Each contract may have multiple
constructors, so those are additionally prefixed with a hash of their type
signature which makes them unique. The generated default constructor
follows the same convention, since it's only emitted when no constructor is
present.

Each emitted transaction is enhanced with an additional argument, \yulsrc{this}, in the first position, which we assume to be an address
in either memory or storage that has the instance upon which the
transaction should operate. 

\subsection{Memory Management}
Fields are written into memory in the order in
which they appear in the Obsidian source; since the size of each is given
by its type, which is known to the compiler statically, it is easy to
compute offsets against \yulsrc{this} to locate field values in
memory. Since we know which fields are primitives and which are references
to instances of other contracts, and know which pointers are in memory and
storage because of our threshold invariant, we know at runtime how to
follow references and which commands to use to do so.

\begin{figure}[hbtp]
    \caption{Selected Translated Transactions}
    \label{code.8}
    \begin{lstlisting}[language=yul,frame=single]
function SetGetWithArgs___main(this) -> _ret_1 {
    let _tmp_14
    let _tmp_15 := allocate_memory(64)
    switch gt(add(this, 0), sub(shl(255, 1), 1))
    case 1 {sstore(add(this, 0), 1)}
    case 0 {mstore(add(this, 0), 1)}

    _tmp_14 := _tmp_15
    let ic := _tmp_14
    let _tmp_16
    _tmp_16 := ic
    let _tmp_17
    _tmp_17 := 5
    IntContainer___set(_tmp_16, _tmp_17)
    let _tmp_18
    let _tmp_19
    _tmp_19 := ic
    let _tmp_20 := IntContainer___get(_tmp_19)
    _tmp_18 := _tmp_20
    _ret_1 := _tmp_18
    leave
}

function IntContainer___set(this, value) {
    let _tmp_34
    _tmp_34 := value
    switch gt(add(this, 32), sub(shl(255, 1), 1))
    case 1 {sstore(add(this, 32), _tmp_34)}
    case 0 {mstore(add(this, 32), _tmp_34)}
}

function IntContainer___get(this) -> _ret_2 {
    let _tmp_35
    let _tmp_36
    switch gt(add(this, 32), sub(shl(255, 1), 1))
    case 1 {_tmp_36 := sload(add(this, 32))}
    case 0 {_tmp_36 := mload(add(this, 32))}

    _tmp_35 := _tmp_36
    _ret_2 := _tmp_35
    leave
}
    \end{lstlisting}
\end{figure}

To enable garbage collection, the compiler adds a field to each contract
before translation to count the number of references to each instance of
that object in storage. At instance creation time, during execution, the
field starts at $1$; if it is ever $0$, it's safe to reclaim that the space
in storage occupied by that instance. This field is used internally only,
it is not directly available to the Obsidian programmer. Instead, they are
offered methods \obssrc{retain} and \obssrc{release} for every
object. \obssrc{retain} increments the reference counter field, and is
called by the programmer to indicate that they are not yet done with a
particular instance; \obssrc{release} decrements the counter and triggers
the wiper functions on the relevant storage address if appropriate. Examples are shown in \cref{code.9} in the appendix.


\subsection{Practicalities}
When passed the \texttt{-{}-yul} flag, the Obsidian compiler targets Ethereum and emits Yul. To run the emitted Yul code, we invoke \texttt{solc} to produce EVM
bytecode via a testing harness written in Python. The harness then starts
and interacts with a Ganache instance via RPC calls and ABI-encoded data
payloads, relying on the Python web3 library. This yields an integer answer
to a specified transaction call against the deployed object as well as
logging artifacts and observable changes to storage, which the harness
compares to expected values per test.