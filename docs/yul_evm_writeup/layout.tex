The Obsidian compiler targets either the Fabric framework or Yul. Here we
are only concerned with the latter, and the implementations do not
interact.

To run the emitted Yul code, we invoke \texttt{solc} to produce EVM
bytecode via a testing harness written in Python, which then starts and
interacts with a Ganache instance with RFC calls and ABI-encoded data
payloads, relying on the Python web3 library. This process yields an
integer answer to a specified transaction call against the deployed object
as well as logging artifacts and observable changes to storage, which the
test compares to expected values per test.

In each test case, we consider translating a collection of one or more
Obsidian contracts, exactly one of which is the \emph{main} contract,
explicitly denoted with the \obssrc{main} keyword. The general shape of the
Yul object emitted as a result of the translation is given in
Figure \ref{code.1}.

\begin{figure}[hbtp]
    \caption{Structure of Generated Yul Object}
    \label{code.1}
    \begin{lstlisting}[language=yul,frame=single]
object "MainContractName" {
    code { // the deployment block
        // 1. memory allocation (identical to below)
        // 2. default constructor for main (identical to below)
        // 3. generated tracers (identical to below)
        // 4. build the default main contract instance, trace it
    }
    object "MainContractName_deployed" { // the invocation block
        // 1. sanity checks
        // 2. dispatch table, inspecting calldataload, using main contract
          //   in storage
        // 3. memory allocation
        // 3. utility functions for abi encoding and decoding
        // 4. translated transactions, including gc and constructors
        // 5. generated constructors
        // 6. generated tracers
        // 7. generated wipers
    }
}
    \end{lstlisting}
\end{figure}

\subsection{Per-contract Generated Transactions}

The compiler emits a default constructor transaction for any contract that
lacks a constructor. In the style of C++, this default constructor takes
enough arguments to populate the fields of the contract. \cite{TODO} Space
for each argument is allocated in memory and the argument values are
written there. If a particular field is not of primitive type, then its
respective default constructor is called recursively with an appropriate
sized slice of the arguments, and the space allocated in memory for the
instance of the parent object is populated with a pointer to the instance
built by the constructor for the child object. In this way, we guarantee
that there is always a way to build an instance of each object in memory.

The compiler also emits two collections of traversal functions for the
contracts given in Obsidian.

The first is the collection of \emph{tracers}, of which there is one per
contract in the source Obsidian file. The purpose of the tracers is to
traverse the region of memory allocated to an instance of an object in
memory and copy it to storage. Each tracer takes the address in memory of
an instance of its respective object and copies its fields to
storage. Fields of primitive type are copied directly. Fields of
non-primitive type, that store pointers to instances of other objects, are
copied by calling the relevant tracer for the contract type recursively on
the location given by the pointer.

We maintain the invariant that all addresses in memory are less than
a \emph{threshold value} all addresses in storage are greater or equal to
it. That value is $2^{256}/2$ or, concretely a \yulsrc{uint32} that looks
like \texttt{0x80...0}, which marks the midpoint of the address space of
storage. This offset invariant effectively halves the size of storage, but
by doing so allows us to know at runtime where an address lives and use the
appropriate commands on it, i.e. picking between \yulsrc{mload}
and \yulsrc{sload}. Since storage is so large and the smart contracts we
are interested in are quite modest in size, the storage reduction is not
problematic.

To maintain this invariant, when a tracer writes a reference to storage,
the address value of the pointer itself is increased by the threshold
value. Since the other tracers do the same, inductively we know that this
shifting operation will preserve structures as they are copied.

The second is the collection of \emph{wipers}. They follow the same
recursive call structure induced by the dependency tree of the contracts in
question, but rather than copying an instance from memory to storage they
write zeroes to all the storage spaces. Per the Yellow Paper, this triggers
a 15,000 gas refund against the initial 20,000 gas cost of a cold write to
storage which is how we amortize the cost of the copying
operation. \cite{TODO}


\subsection{The Deployment Block}

The main task at deployment time is to build an instance of the main
contract in memory and then copy that to storage. This copy serves as the
root object for garbage collection. Note that three of the main components
in this block are copied verbatim from general purpose versions that exist
at invocation time, lower in the emitted object; this is a site for future
optimization.

To that end, the deployment block begins with a copy of the memory
allocator and associated utility functions, followed by the generated
default constructors and tracers. Currently we emit all the constructors
and tracers, although they may not be needed; this is site for future
optimization. We allocate enough memory for a copy of the main contract,
use the emitted constructor to build it there, then run the tracer on it to
copy it to storage. Because we know the first address that allocator will
give in memory and the mapping the tracer applies to addresses to compute
their place in storage, we know where this will live in storage and that
serves as the \emph{root}.

\subsection{The Invocation Block}

Instances of Obsidian objects can refer to one another, so their
translations in to Yul must be able to as well. This means at least that
they must have access to the same memory during execution. To that end, we
\emph{flatten} the contracts into one object structured as in Figure
\ref{code.1}.

The block begins with checks against the structure of the call and then
inspects the call data in the dispatch table to determine which transaction
to run, per the ABI encoding. The available transactions are the ones in
the main contract that are not private and not constructors. The
transaction is run against the instance of the main contract that's been
built and copied to storage in the deployment block, which we can assume
has been run first. We know the address in storage of this root instance
statically, since we know the first address that the allocator will emit as
well as the threshold value by which it will have been offset.

This is followed by a simple memory allocator and functions for
manipulating data against the ABI specified encoding and decodings.

This is followed by the transactions from the contracts. The name of each
transaction is prefixed with the name of its origin contract in the
translation; the structure of Obsidian files guarantees that this is
unique. Each contract may have multiple constructors, so those are
additionally prefixed with a hash of their type signature which makes them
unique. The generated default constructor follows the same convention,
since it's only emitted when no constructor is present.

Each emitted transaction is enhanced with an additional argument
named \yulsrc{this} in the first position which we assume to be an address
in either memory or storage that has the instance upon which the
transaction should operate. Fields are written into memory in the order in
which they appear in the Obsidian source; since the size of each is given
by its type, which is known to the compiler statically, it is easy to
compute offsets against \yulsrc{this} to locate field values in
memory. Since we know which fields are primitives and which are references
to instances of other contracts, and know which pointers are in memory and
storage because of our threshold invariant, we know at runtime how to
follow references and which commands to use to do so.

To enable garbage collection, the compiler adds a field to each contract
before translation to count the number of references to each instance of
that object in storage. At instance creation time, during execution, the
field starts at $1$; if it is ever $0$, it's safe to reclaim that the space
in storage occupied by that instance. This field is used internally only,
it is not directly available to the Obsidian programmer. Instead, they are
offered methods \obssrc{retain} and \obssrc{release} for every
object. \obssrc{retain} increments the reference counter field, and is
called by the programmer to indicate that they are not yet done with a
particular instance; \obssrc{release} decrements the counter and triggers
the wiper functions on the relevant storage address if appropriate.

The implementations of these are emitted next in the invocation block,
followed by the constructors, tracers, and wipers as described above.
