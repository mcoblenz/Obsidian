The Obsidian compiler targets eAAither the Fabric framework or Yul. Here we
are only concerned with the latter, and the implementations do not
interact.

To run the emitted Yul code, we invoke \texttt{solc} to produce EVM
bytecode via a testing harness written in Python. The harness then starts
and interacts with a Ganache instance via RPC calls and ABI-encoded data
payloads, relying on the Python web3 library. This yields an integer answer
to a specified transaction call against the deployed object as well as
logging artifacts and observable changes to storage, which the harness
compares to expected values per test.

In each test case, we consider translating a collection of one or more
Obsidian contracts, exactly one of which is the \emph{main} contract,
explicitly denoted with the \obssrc{main} keyword. The general shape of the
Yul object emitted as a result of the translation is given in
Figure \ref{code.1}.

\begin{figure}[hbtp]
    \caption{Structure of Generated Yul Object}
    \label{code.1}
    \begin{lstlisting}[language=yul,frame=single]
object "MainContractName" {
    code { // the deployment block
        // 1. memory allocation (identical to below)
        // 2. default constructor for main (identical to below)
        // 3. generated tracers (identical to below)
        // 4. build the default main contract instance, trace it
    }
    object "MainContractName_deployed" { // the invocation block
        // 1. sanity checks
        // 2. dispatch table, inspecting calldataload, using main contract
          //   in storage
        // 3. memory allocation
        // 3. utility functions for abi encoding and decoding
        // 4. translated transactions, including gc and constructors
        // 5. generated constructors
        // 6. generated tracers
        // 7. generated wipers
    }
}
    \end{lstlisting}
\end{figure}

In Figure \ref{code.2} we show a simple pair of Obsidian contracts. This
will be our running example in this section; as we describe different
aspects of the translation, we provide snippets of the emitted code
produced on this contract.

\begin{figure}[hbtp]
    \caption{Example Obsidian Setter Getter Contract Pair}
    \label{code.2}
    \begin{lstlisting}[language=obsidian,frame=single]
contract IntContainer{
    int x;

    transaction set(int value) {
        x = value;
    }
    transaction get() returns int{
        return x;
    }
}

main contract SetGetWithArgs{
    transaction main() returns int{
        IntContainer ic = new IntContainer();
        ic.set(5);
        return (ic.get());
    }
}
    \end{lstlisting}
\end{figure}



\subsection{Per-contract Generated Transactions}

The compiler emits a default constructor transaction for any contract that
lacks a constructor. In the style of C++, this default constructor takes
enough arguments to populate the fields of the contract. \cite{TODO} Space
for each argument is allocated in memory and the argument values are
written there. If a particular field is not of primitive type, then its
respective default constructor is called recursively with an appropriate
slice of the arguments and the space allocated in memory for the instance
of the parent object is populated with a pointer to the instance built by
the constructor for the child object. In this way, we guarantee that there
is always a way to build an instance of each object in memory.

\begin{figure}[hbtp]
    \caption{Default Constructors}
    \label{code.3}
    \begin{lstlisting}[language=yul,frame=single]
function SetGetWithArgs___SetGetWithArgs0x050caf6b(this, con_arg____refcount) {
    // default constructor generated by the compiler
    // this.__refcount := con_arg____refcount
    switch gt(add(this, 0), sub(shl(255, 1), 1))
    case 1 {sstore(add(this, 0), con_arg____refcount)}
    case 0 {mstore(add(this, 0), con_arg____refcount)}
}

function IntContainer___IntContainer0x13e375fe(this, con_arg____refcount, con_arg__x) {
    // default constructor generated by the compiler
    // this.__refcount := con_arg____refcount
    switch gt(add(this, 0), sub(shl(255, 1), 1))
    case 1 {sstore(add(this, 0), con_arg____refcount)}
    case 0 {mstore(add(this, 0), con_arg____refcount)}

    // this.x := con_arg__x
    switch gt(add(this, 32), sub(shl(255, 1), 1))
    case 1 {sstore(add(this, 32), con_arg__x)}
    case 0 {mstore(add(this, 32), con_arg__x)}
}
\end{lstlisting}
\end{figure}

The compiler also emits two collections of traversal functions for the
contracts given in Obsidian: \emph{tracers} and \emph{wipers}. There is one
of each for every contract in the Obsidian source.

The tracers is to traverse the region of memory allocated to an instance of
an object in memory and copy it to storage. Each tracer takes the address
in memory of an instance of its respective object and copies its fields to
storage. Fields of primitive type are copied directly. Fields of
non-primitive type, that store pointers to instances of other objects, are
copied by calling the relevant tracer for the contract type recursively on
the location given by the pointer.

\begin{figure}[hbtp]
    \caption{Tracers, with logging}
    \label{code.4}
    \begin{lstlisting}[language=yul,frame=single]
function trace_SetGetWithArgs(this) {
    // loading
    sstore(add(add(this, 0), shl(255, 1)), mload(add(this, 0)))
    // logging
    let _tmp_37 := allocate_memory(32)
    mstore(_tmp_37, sload(add(add(this, 0), shl(255, 1))))
    log0(_tmp_37, 32)
    leave
}

function trace_IntContainer(this) {
    // loading
    sstore(add(add(this, 0), shl(255, 1)), mload(add(this, 0)))
    // logging
    let _tmp_38 := allocate_memory(32)
    mstore(_tmp_38, sload(add(add(this, 0), shl(255, 1))))
    log0(_tmp_38, 32)
    // loading
    sstore(add(add(this, 32), shl(255, 1)), mload(add(this, 32)))
    // logging
    let _tmp_39 := allocate_memory(32)
    mstore(_tmp_39, sload(add(add(this, 32), shl(255, 1))))
    log0(_tmp_39, 32)
    leave
}
    \end{lstlisting}
\end{figure}

We maintain the invariant that all addresses in memory are less than
a \emph{threshold value} all addresses in storage are greater or equal to
it. That value is $2^{256}/2$ or, concretely a \yulsrc{uint32} that looks
like \texttt{0x80...0}, which marks the midpoint of the address space of
storage. This offset invariant effectively halves the size of storage, but
by doing so allows us to know at runtime where an address lives and use the
appropriate commands on it, i.e. picking between \yulsrc{mload}
and \yulsrc{sload}. Since storage is so large and the smart contracts we
are interested in are quite modest in size, the storage reduction is not
problematic.

To maintain this invariant, when a tracer writes a reference to storage,
the address value of the pointer itself is increased by the threshold
value. Since the other tracers do the same, inductively we know that this
shifting operation will preserve structures as they are copied.

The wipers follow the same recursive call structure induced by the
dependency tree of the contracts in question, but rather than copying an
instance from memory to storage they write zeroes to all the storage
spaces. Per the Yellow Paper, this triggers a 15,000 gas refund against the
initial 20,000 gas cost of a cold write to storage which is how we amortize
the cost of the copying operation. \cite{TODO}

\begin{figure}[hbtp]
    \caption{Wipers, with logging}
    \label{code.5}
    \begin{lstlisting}[language=yul,frame=single]
function wipe_SetGetWithArgs(this) {
    // wiping
    sstore(add(this, 0), 0)
    // logging
    let _tmp_40 := allocate_memory(32)
    mstore(_tmp_40, 20)
    log0(_tmp_40, 32)
    leave
}

function wipe_IntContainer(this) {
    // wiping
    sstore(add(this, 0), 0)
    // logging
    let _tmp_41 := allocate_memory(32)
    mstore(_tmp_41, 20)
    log0(_tmp_41, 32)
    // wiping
    sstore(add(this, 32), 0)
    // logging
    let _tmp_42 := allocate_memory(32)
    mstore(_tmp_42, 20)
    log0(_tmp_42, 32)
    leave
}
    \end{lstlisting}
\end{figure}


\subsection{The Deployment Block}

The main task at deployment time is to build an instance of the main
contract in memory and then copy that to storage. This copy serves as the
root object for garbage collection. Note that three of the main components
in this block are copied verbatim from general purpose versions that exist
at invocation time, lower in the emitted object; this is a site for future
optimization.

To that end, the deployment block begins with a copy of the memory
allocator and associated utility functions, followed by the generated
default constructors and tracers. Currently we emit all the constructors
and tracers, although they may not be needed; this is site for future
optimization. We allocate enough memory for a copy of the main contract,
use the emitted constructor to build it there, then run the tracer on it to
copy it to storage. Because we know the first address that allocator will
give in memory and the mapping the tracer applies to addresses to compute
their place in storage, we know where this will live in storage and that
serves as the \emph{root}.

\begin{figure}[hbtp]
    \caption{Building the Root}
    \label{code.6}
    \begin{lstlisting}[language=yul,frame=single]
let this := allocate_memory(32)
SetGetWithArgs___SetGetWithArgs0x050caf6b(this, 5738)
trace_SetGetWithArgs(this)
    \end{lstlisting}
\end{figure}

\subsection{The Invocation Block}

Instances of Obsidian objects can refer to one another, so their
translations in to Yul must be able to as well. This means at least that
they must have access to the same memory during execution. To that end, we
\emph{flatten} the contracts into one object structured as in Figure
\ref{code.1}.

\begin{figure}[hbtp]
    \caption{Dispatch Table}
    \label{code.7}
    \begin{lstlisting}[language=yul,frame=single]
// fixed address of the root
let this := add(shl(255, 1), 128)

let selector := shr(224, calldataload(0))
switch selector
case 0xd1665b62 {// entry for SetGetWithArgs___main
    if callvalue() {revert(0, 0)}
    // SetGetWithArgs___main takes no parameters
    let _dd_ret_1 := SetGetWithArgs___main(this)
    let memPos := allocate_unbounded()
    let memEnd := abi_encode_tuple_to_fromStack1(memPos, _dd_ret_1)
    return(memPos, sub(memEnd, memPos))
    }
    \end{lstlisting}
\end{figure}

The block begins with checks against the structure of the call and then
inspects the call data in the dispatch table to determine which transaction
to run, per the ABI encoding. The available transactions are the ones in
the main contract that are not private and not constructors. The
transaction is run against the instance of the main contract that's been
built and copied to storage in the deployment block, which we can assume
has been run first. We know the address in storage of this root instance
statically, since we know the first address that the allocator will emit as
well as the threshold value by which it will have been offset.

This is followed by a simple memory allocator and functions for
manipulating data against the ABI specified encoding and decodings.

%% omitting code for the allocator, sanity checks, encoders, and decoders
%% because they are big and not interesting

After the allocator, we emit translation of the transactions from the
contracts. The name of each transaction is prefixed with the name of its
origin contract in the translation; the structure of Obsidian files
guarantees that this is unique. Each contract may have multiple
constructors, so those are additionally prefixed with a hash of their type
signature which makes them unique. The generated default constructor
follows the same convention, since it's only emitted when no constructor is
present.

Each emitted transaction is enhanced with an additional argument
named \yulsrc{this} in the first position which we assume to be an address
in either memory or storage that has the instance upon which the
transaction should operate. Fields are written into memory in the order in
which they appear in the Obsidian source; since the size of each is given
by its type, which is known to the compiler statically, it is easy to
compute offsets against \yulsrc{this} to locate field values in
memory. Since we know which fields are primitives and which are references
to instances of other contracts, and know which pointers are in memory and
storage because of our threshold invariant, we know at runtime how to
follow references and which commands to use to do so.

\begin{figure}[hbtp]
    \caption{Selected Translated Transactions}
    \label{code.8}
    \begin{lstlisting}[language=yul,frame=single]
function SetGetWithArgs___main(this) -> _ret_1 {
    let _tmp_14
    let _tmp_15 := allocate_memory(64)
    switch gt(add(this, 0), sub(shl(255, 1), 1))
    case 1 {sstore(add(this, 0), 1)}
    case 0 {mstore(add(this, 0), 1)}

    _tmp_14 := _tmp_15
    let ic := _tmp_14
    let _tmp_16
    _tmp_16 := ic
    let _tmp_17
    _tmp_17 := 5
    IntContainer___set(_tmp_16, _tmp_17)
    let _tmp_18
    let _tmp_19
    _tmp_19 := ic
    let _tmp_20 := IntContainer___get(_tmp_19)
    _tmp_18 := _tmp_20
    _ret_1 := _tmp_18
    leave
}

function IntContainer___set(this, value) {
    let _tmp_34
    _tmp_34 := value
    switch gt(add(this, 32), sub(shl(255, 1), 1))
    case 1 {sstore(add(this, 32), _tmp_34)}
    case 0 {mstore(add(this, 32), _tmp_34)}
}

function IntContainer___get(this) -> _ret_2 {
    let _tmp_35
    let _tmp_36
    switch gt(add(this, 32), sub(shl(255, 1), 1))
    case 1 {_tmp_36 := sload(add(this, 32))}
    case 0 {_tmp_36 := mload(add(this, 32))}

    _tmp_35 := _tmp_36
    _ret_2 := _tmp_35
    leave
}
    \end{lstlisting}
\end{figure}

To enable garbage collection, the compiler adds a field to each contract
before translation to count the number of references to each instance of
that object in storage. At instance creation time, during execution, the
field starts at $1$; if it is ever $0$, it's safe to reclaim that the space
in storage occupied by that instance. This field is used internally only,
it is not directly available to the Obsidian programmer. Instead, they are
offered methods \obssrc{retain} and \obssrc{release} for every
object. \obssrc{retain} increments the reference counter field, and is
called by the programmer to indicate that they are not yet done with a
particular instance; \obssrc{release} decrements the counter and triggers
the wiper functions on the relevant storage address if appropriate.

\begin{figure}[hbtp]
    \caption{Selected Garbage Collection Methods}
    \label{code.9}
    \begin{lstlisting}[language=yul,frame=single]
function SetGetWithArgs___retain(this) {
    let _tmp_1
    let _tmp_2
    let _tmp_4
    let _tmp_3
    switch gt(add(this, 0), sub(shl(255, 1), 1))
    case 1 {_tmp_3 := sload(add(this, 0))}
    case 0 {_tmp_3 := mload(add(this, 0))}

    _tmp_2 := _tmp_3
    _tmp_4 := 1
    _tmp_1 := add(_tmp_2, _tmp_4)
    switch gt(add(this, 0), sub(shl(255, 1), 1))
    case 1 {sstore(add(this, 0), _tmp_1)}
    case 0 {mstore(add(this, 0), _tmp_1)}
    leave
}

function SetGetWithArgs___release(this) {
    let _tmp_5
    let _tmp_6
    let _tmp_8
    let _tmp_7
    switch gt(add(this, 0), sub(shl(255, 1), 1))
    case 1 {_tmp_7 := sload(add(this, 0))}
    case 0 {_tmp_7 := mload(add(this, 0))}

    _tmp_6 := _tmp_7
    _tmp_8 := 1
    _tmp_5 := sub(_tmp_6, _tmp_8)
    switch gt(add(this, 0), sub(shl(255, 1), 1))
    case 1 {sstore(add(this, 0), _tmp_5)}
    case 0 {mstore(add(this, 0), _tmp_5)}

    let _tmp_9
    let _tmp_10
    let _tmp_12
    let _tmp_11
    switch gt(add(this, 0), sub(shl(255, 1), 1))
    case 1 {_tmp_11 := sload(add(this, 0))}
    case 0 {_tmp_11 := mload(add(this, 0))}

    _tmp_10 := _tmp_11
    _tmp_12 := 0
    _tmp_9 := eq(_tmp_10, _tmp_12)
    if _tmp_9 {let _tmp_13
               SetGetWithArgs___dealloc(this)}
    leave
}

function SetGetWithArgs___dealloc(this) {
    wipe_SetGetWithArgs(this)
}

    \end{lstlisting}
\end{figure}

The implementations of these are emitted next in the invocation block,
followed by the constructors, tracers, and wipers as described above.
