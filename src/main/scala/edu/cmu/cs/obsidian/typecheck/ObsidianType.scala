package edu.cmu.cs.obsidian.typecheck
import edu.cmu.cs.obsidian.parser._

sealed abstract class TypeModifier() extends HasLocation
case class IsReadOnly() extends TypeModifier {
    override def toString: String = "readonly"
}

case class IsRemote() extends TypeModifier {
    override def toString: String = "remote"
}

case class IsOwned() extends TypeModifier {
    override def toString: String = "owned"
}


/* [SimpleType] simply indicates a contract, and possibly a state or set of states: there
 * is neither a permission nor a path associated with the type */
sealed trait SimpleType { val contractName: String }

case class JustContractType(contractName: String) extends SimpleType {
    override def toString: String = contractName
}
/* Invariant: [stateNames] is missing at least one of the states of the
 * contract (i.e. it is more specific than [JustContractType(contractName)],
 * but has at least 2 distinct states */
case class StateUnionType(contractName: String, stateNames: Set[String]) extends SimpleType {
    private def orOfStates: String = stateNames.toSeq.tail.foldLeft(stateNames.head)(
        (prev: String, sName: String) => prev + " | " + sName
    )
    override def toString: String = contractName + "." + "(" + orOfStates + ")"
}

case class StateType(contractName: String, stateName: String) extends SimpleType {
    override def toString: String = contractName + "." + stateName
}


/* [UnpermissionedType] is a contract type that doesn't have a permission associated with it,
 * but potentially has a path. */
sealed trait UnpermissionedType { // NOT an ObsidianType!
    val extractSimpleType: SimpleType
}

case class NoPathType(ts: SimpleType) extends UnpermissionedType {
    override def toString: String = ts.toString
    override val extractSimpleType: SimpleType = ts
}

/* a path starts with either a local variable or "this", but "this" can sometimes be omitted */
case class PathType(path: Seq[String], ts: SimpleType) extends UnpermissionedType {
    private def pathAsString = path.foldLeft("")(
        (prev: String, pathNode: String) => prev + pathNode + "."
    )
    override def toString: String = pathAsString + ts.toString
    override val extractSimpleType: SimpleType = ts
}

/* Invariant for permissioned types: any path that occurs in the type makes "this" explicit */
sealed trait ObsidianType extends HasLocation {
    // for tests
    val isBottom: Boolean
    val tableOpt: Option[DeclarationTable]

    /* the permission system doesn't allow arbitrary aliasing of a reference
     * typed as [t]: aliasing forces one of the resulting types to be
     * [residualType(t)] instead */
    val residualType: ObsidianType

    val extractSimpleType: Option[SimpleType]
    val extractUnpermissionedType: Option[UnpermissionedType]

    def isOwned = false
    def isShared = false
    def isReadOnly = false
    def isRemote = false
}

sealed trait PotentiallyUnresolvedType extends ObsidianType
sealed trait ResolvedType extends ObsidianType

/* int, bool, or string */
sealed trait PrimitiveType extends PotentiallyUnresolvedType with ResolvedType {
    val isBottom: Boolean = false
    val tableOpt: Option[DeclarationTable] = None
    override val residualType: ObsidianType = this
    override val extractSimpleType: Option[SimpleType] = None
    override val extractUnpermissionedType: Option[UnpermissionedType] = None
}

/* all permissioned types are associated with their corresponding symbol table
 * These types were generated by resolution; they are not generated by the parser.
 */
case class NonPrimitiveType(tableOf: DeclarationTable,
                            t: UnpermissionedType,
                            modifiers: Set[TypeModifier]) extends ResolvedType {
    val isBottom: Boolean = false
    def table: DeclarationTable = tableOf
    val tableOpt: Option[DeclarationTable] = Some(table)

    override def toString: String = modifiers.map(m => m.toString).mkString(" ") + " " + t.toString
    override def equals(other: Any): Boolean = {
        other match {
            case NonPrimitiveType(_, typ, mod) => typ == t && mod == modifiers
            case _ => false
        }
    }
    override def hashCode(): Int = t.hashCode()
    val residualType: ObsidianType = if (modifiers.contains(IsOwned()))
        NonPrimitiveType(tableOf, t, modifiers - IsOwned() + IsReadOnly())
    else this

    val extractSimpleType: Option[SimpleType] = Some(t.extractSimpleType)
    val extractUnpermissionedType: Option[UnpermissionedType] = Some(t)

    override def isOwned = modifiers.contains(IsOwned())
    override def isReadOnly = modifiers.contains(IsReadOnly())
    override def isRemote = modifiers.contains(IsRemote())
}


case class IntType() extends PrimitiveType {
    override def toString: String = "int"
}
case class BoolType() extends PrimitiveType {
    override def toString: String = "bool"
}
case class StringType() extends PrimitiveType {
    override def toString: String = "string"
}
/* Used to indicate an error in the type checker when a reasonable type cannot
 * otherwise be inferred */
case class BottomType() extends ResolvedType {
    val isBottom: Boolean = true
    val tableOpt: Option[DeclarationTable] = None
    override val residualType: ObsidianType = this
    override val extractSimpleType: Option[SimpleType] = None
    override val extractUnpermissionedType: Option[UnpermissionedType] = None
}

// Only appears before running resolution, which happens right after parsing.
case class UnresolvedNonprimitiveType(identifiers: Seq[String], mods: Set[TypeModifier]) extends PotentiallyUnresolvedType {
    val isBottom: Boolean = false
    val tableOpt: Option[DeclarationTable] = None
    override val residualType: ObsidianType = this // Should never be invoked
    override val extractSimpleType: Option[SimpleType] = None

    override val extractUnpermissionedType: Option[UnpermissionedType] = None
}
